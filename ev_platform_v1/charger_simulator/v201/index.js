const WebSocket = require('ws');
const { v4: uuidv4 } = require('uuid');

// Configuration
const CHARGER_ID = 'CH001';
// Note: Backend URL for 2.0.1
const BACKEND_URL = `ws://localhost:9220/Quantum/OCPP/2.0.1/${CHARGER_ID}`;

console.log(`Connecting to ${BACKEND_URL}...`);

const ws = new WebSocket(BACKEND_URL, 'ocpp2.0.1');

let messageId = 1;
let heartbeatInterval;
let transactionId = uuidv4(); // OCPP 2.0.1 uses strings (often UUIDs) generated by CS or CSM

function getMessageId() {
    return (messageId++).toString();
}

ws.on('open', function open() {
    console.log('Connected to Backend (OCPP 2.0.1)!');

    // 1. BootNotification
    const bootNotification = [
        2,
        getMessageId(),
        "BootNotification",
        {
            "reason": "PowerUp",
            "chargingStation": {
                "model": "Simulator-201",
                "vendorName": "Quantum",
                "firmwareVersion": "2.0.1",
                "serialNumber": "SIM201"
            }
        }
    ];

    send(bootNotification);
});

ws.on('message', function incoming(data) {
    const msg = JSON.parse(data);
    const msgType = msg[0];

    // Explicit Logging of Incoming Server Frames
    if (msgType === 2) { // CALL
        console.log(`\n[SERVER REQUEST] >>> ${msg[2]} (ID: ${msg[1]})`);
        console.log(JSON.stringify(msg, null, 2));
    } else if (msgType === 3) { // CALLRESULT
        console.log(`\n[SERVER RESPONSE] >>> To Request ID: ${msg[1]}`);
        console.log(JSON.stringify(msg, null, 2));
    } else if (msgType === 4) { // CALLERROR
         console.log(`\n[SERVER ERROR] >>> To Request ID: ${msg[1]}`);
         console.log(JSON.stringify(msg, null, 2));
    } else {
        console.log(`\n[UNKNOWN FRAME] >>>`);
        console.log(JSON.stringify(msg, null, 2));
    }
    
    // CALLRESULT
    if (msgType === 3) {
        const requestId = msg[1];
        const payload = msg[2];
        
        // Handle BootNotification Response
        // Note: 2.0.1 status is 'Accepted' | 'Pending' | 'Rejected'
        if (payload.status === 'Accepted' && payload.interval) {
            console.log('BootNotification Accepted. Starting Heartbeat and Status...');
            
            // Start Heartbeat
            startHeartbeat(payload.interval);

            // Send StatusNotification (Available)
            sendStatusNotification('Available');

            // Simulate a transaction flow after 5 seconds
            setTimeout(() => {
                startTransactionFlow();
            }, 5000);
        }
    }
    
    // CALL
    else if (msgType === 2) {
        const requestId = msg[1];
        const action = msg[2];
        // Simple auto-accept for now
        send([3, requestId, {}]);
    }
});

ws.on('close', function close(code, reason) {
    console.log(`Disconnected. Code: ${code}, Reason: ${reason}`);
    clearInterval(heartbeatInterval);
});

ws.on('error', function error(err) {
    console.error('WebSocket Error:', err);
});

function send(msg) {
    const msgType = msg[0];
    if (msgType === 2) {
        console.log(`\n[CLIENT REQUEST] <<< ${msg[2]} (ID: ${msg[1]})`);
    } else if (msgType === 3) {
         console.log(`\n[CLIENT RESPONSE] <<< To Request ID: ${msg[1]}`);
    } else {
        console.log(`\n[CLIENT MESSAGE] <<<`);
    }
    console.log(JSON.stringify(msg, null, 2));
    ws.send(JSON.stringify(msg));
}

function startHeartbeat(interval) {
    if (heartbeatInterval) clearInterval(heartbeatInterval);
    console.log(`Heartbeat interval set to ${interval}s`);
    heartbeatInterval = setInterval(() => {
        send([
            2,
            getMessageId(),
            "Heartbeat",
            {}
        ]);
    }, interval * 1000);
}

function sendStatusNotification(connectorStatus) {
    // OCPP 2.0.1 StatusNotification
    send([
        2,
        getMessageId(),
        "StatusNotification",
        {
            "timestamp": new Date().toISOString(),
            "connectorStatus": connectorStatus, // Available, Occupied, Reserved, Unavailable, Faulted
            "evseId": 1,
            "connectorId": 1
        }
    ]);
}

function startTransactionFlow() {
    console.log('--- Starting Transaction Sequence (OCPP 2.0.1) ---');
    
    const idToken = { "idToken": "TAG001", "type": "ISO14443" };
    
    // 1. TransactionEvent (Started)
    // In 2.0.1, Authorize is optional if you send idToken in TransactionEvent(Started) 
    // or you can do Authorize first. Let's do Authorize first for completeness if needed, 
    // but the handler I read mainly processes TransactionEvent.
    // Let's go straight to TransactionEvent(Started) which is common.
    
    sendStatusNotification('Occupied'); // Plugged in

    const txStarted = [
        2,
        getMessageId(),
        "TransactionEvent",
        {
            "eventType": "Started",
            "timestamp": new Date().toISOString(),
            "triggerReason": "CablePluggedIn",
            "seqNo": 0,
            "transactionInfo": {
                "transactionId": transactionId
            },
            "idToken": idToken,
            "evse": { "id": 1, "connectorId": 1 },
            "meterValue": [
                {
                    "timestamp": new Date().toISOString(),
                    "sampledValue": [
                        { "value": "0", "context": "Transaction.Begin", "measurand": "Energy.Active.Import.Register", "unit": "Wh" }
                    ]
                }
            ]
        }
    ];
    send(txStarted);
    
    // 2. TransactionEvent (Updated) - Simulating charging
    setTimeout(() => {
        const txUpdated = [
            2,
            getMessageId(),
            "TransactionEvent",
            {
                "eventType": "Updated",
                "timestamp": new Date().toISOString(),
                "triggerReason": "MeterValuePeriodic",
                "seqNo": 1,
                "transactionInfo": {
                    "transactionId": transactionId
                },
                "meterValue": [
                    {
                        "timestamp": new Date().toISOString(),
                        "sampledValue": [
                            { "value": "100", "context": "Sample.Periodic", "measurand": "Energy.Active.Import.Register", "unit": "Wh" }
                        ]
                    }
                ]
            }
        ];
        send(txUpdated);
    }, 5000);
    
    // 3. TransactionEvent (Ended)
    setTimeout(() => {
        const txEnded = [
            2,
            getMessageId(),
            "TransactionEvent",
            {
                "eventType": "Ended",
                "timestamp": new Date().toISOString(),
                "triggerReason": "EVCommunicationLost", // or RemoteStop, EVConnect, etc
                "seqNo": 2,
                "transactionInfo": {
                    "transactionId": transactionId
                },
                "idToken": idToken,
                "meterValue": [
                    {
                        "timestamp": new Date().toISOString(),
                        "sampledValue": [
                            { "value": "250", "context": "Transaction.End", "measurand": "Energy.Active.Import.Register", "unit": "Wh" }
                        ]
                    }
                ]
            }
        ];
        send(txEnded);
        
        sendStatusNotification('Available');
        
        // Generate new transaction ID for next time
        transactionId = uuidv4();
        
    }, 10000);
}
